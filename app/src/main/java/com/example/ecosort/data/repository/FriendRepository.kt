package com.example.ecosort.data.repository

import com.example.ecosort.data.local.*
import com.example.ecosort.data.model.*
import com.example.ecosort.data.firebase.FirestoreService
import com.example.ecosort.data.firebase.FirebaseFriendRequest
import com.example.ecosort.data.firebase.FirebaseFriendship
import com.google.firebase.Timestamp
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FriendRepository @Inject constructor(
    private val userDao: UserDao,
    private val friendRequestDao: FriendRequestDao,
    private val friendshipDao: FriendshipDao,
    private val blockedUserDao: BlockedUserDao,
    private val firestoreService: FirestoreService
) {

    // ==================== FRIEND REQUESTS ====================

    suspend fun sendFriendRequest(senderId: Long, receiverId: Long, message: String? = null): Result<Long> {
        return try {
            android.util.Log.d("FriendRepository", "sendFriendRequest: sender=$senderId, receiver=$receiverId")
            
            // Check if users are already friends
            val existingFriendship = friendshipDao.getFriendshipBetweenUsers(senderId, receiverId)
            if (existingFriendship != null) {
                return Result.Error(Exception("Users are already friends"))
            }

            // Check if there's already a pending request
            val existingRequest = friendRequestDao.getPendingRequestBetweenUsers(senderId, receiverId)
            if (existingRequest != null) {
                return Result.Error(Exception("Friend request already sent"))
            }

            // Check if users are blocked
            val isBlocked = blockedUserDao.isBlocked(senderId, receiverId)
            if (isBlocked) {
                return Result.Error(Exception("Cannot send friend request to blocked user"))
            }

            // Get sender and receiver Firebase UIDs
            val sender = userDao.getUserById(senderId)
            val receiver = userDao.getUserById(receiverId)
            
            if (sender == null || receiver == null) {
                android.util.Log.e("FriendRepository", "Sender or receiver not found: sender=$sender, receiver=$receiver")
                return Result.Error(Exception("User not found"))
            }
            
            val senderFirebaseUid = sender.firebaseUid
            val receiverFirebaseUid = receiver.firebaseUid
            
            if (senderFirebaseUid.isNullOrEmpty() || receiverFirebaseUid.isNullOrEmpty()) {
                android.util.Log.e("FriendRepository", "Missing Firebase UID: senderUid=$senderFirebaseUid, receiverUid=$receiverFirebaseUid")
                return Result.Error(Exception("User Firebase UID not found"))
            }

            // Save to local database first
            val friendRequest = FriendRequest(
                senderId = senderId,
                receiverId = receiverId,
                message = message
            )
            val requestId = friendRequestDao.insertFriendRequest(friendRequest)
            android.util.Log.d("FriendRepository", "Friend request saved locally with ID: $requestId")

            // Sync to Firebase for cross-device access
            try {
                val firebaseFriendRequest = FirebaseFriendRequest(
                    id = "", // Will be auto-generated by Firebase
                    senderId = senderFirebaseUid,
                    receiverId = receiverFirebaseUid,
                    status = "PENDING",
                    message = message,
                    createdAt = Timestamp.now(),
                    updatedAt = Timestamp.now()
                )
                
                val firebaseResult = firestoreService.sendFriendRequest(firebaseFriendRequest)
                when (firebaseResult) {
                    is Result.Success -> {
                        android.util.Log.d("FriendRepository", "Friend request synced to Firebase with ID: ${firebaseResult.data}")
                    }
                    is Result.Error -> {
                        android.util.Log.e("FriendRepository", "Failed to sync to Firebase", firebaseResult.exception)
                    }
                    else -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FriendRepository", "Error syncing friend request to Firebase", e)
                // Continue - local request was saved successfully
            }

            Result.Success(requestId)

        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error sending friend request", e)
            Result.Error(e)
        }
    }

    fun getPendingFriendRequests(userId: Long): Flow<List<FriendRequest>> {
        return friendRequestDao.getPendingFriendRequests(userId)
    }

    fun getSentFriendRequests(userId: Long): Flow<List<FriendRequest>> {
        return friendRequestDao.getSentFriendRequests(userId)
    }

    suspend fun acceptFriendRequest(requestId: Long, userId: Long): Result<Unit> {
        return try {
            android.util.Log.d("FriendRepository", "acceptFriendRequest: requestId=$requestId, userId=$userId")
            
            val request = friendRequestDao.getFriendRequestById(requestId)
                ?: return Result.Error(Exception("Friend request not found"))

            // Security check: Only the receiver can accept the request
            if (request.receiverId != userId) {
                return Result.Error(SecurityException("Unauthorized to accept this request"))
            }

            // Get sender and receiver users
            val sender = userDao.getUserById(request.senderId)
            val receiver = userDao.getUserById(request.receiverId)
            
            if (sender == null || receiver == null) {
                return Result.Error(Exception("User not found"))
            }

            // Update request status locally
            friendRequestDao.updateFriendRequestStatus(
                requestId, 
                FriendRequestStatus.ACCEPTED, 
                System.currentTimeMillis()
            )
            android.util.Log.d("FriendRepository", "Updated friend request status to ACCEPTED locally")

            // Create friendship locally
            val friendship = Friendship(
                userId1 = request.senderId,
                userId2 = request.receiverId,
                createdAt = System.currentTimeMillis(),
                lastInteraction = System.currentTimeMillis()
            )
            friendshipDao.insertFriendship(friendship)
            android.util.Log.d("FriendRepository", "Created friendship locally: ${sender.username} ↔ ${receiver.username}")

            // Sync to Firebase
            try {
                val senderFirebaseUid = sender.firebaseUid
                val receiverFirebaseUid = receiver.firebaseUid
                
                if (!senderFirebaseUid.isNullOrEmpty() && !receiverFirebaseUid.isNullOrEmpty()) {
                    // Update friend request status in Firebase
                    val firebaseRequestsFlow = firestoreService.getPendingFriendRequests(receiverFirebaseUid)
                    val firebaseRequests = firebaseRequestsFlow.first()
                    val firebaseRequest = firebaseRequests.find { 
                        it.senderId == senderFirebaseUid && it.receiverId == receiverFirebaseUid 
                    }
                    
                    if (firebaseRequest != null) {
                        firestoreService.updateFriendRequestStatus(firebaseRequest.id, "ACCEPTED")
                        android.util.Log.d("FriendRepository", "Updated Firebase friend request to ACCEPTED")
                    }
                    
                    // Create friendship in Firebase (ensure userId1 < userId2 for consistency)
                    val sortedIds = listOf(senderFirebaseUid, receiverFirebaseUid).sorted()
                    val firebaseFriendship = FirebaseFriendship(
                        id = "", // Auto-generated
                        userId1 = sortedIds[0],
                        userId2 = sortedIds[1],
                        createdAt = Timestamp.now(),
                        lastInteraction = Timestamp.now()
                    )
                    
                    val friendshipResult = firestoreService.createFriendship(firebaseFriendship)
                    when (friendshipResult) {
                        is Result.Success -> {
                            android.util.Log.d("FriendRepository", "Created friendship in Firebase: ${friendshipResult.data}")
                        }
                        is Result.Error -> {
                            android.util.Log.e("FriendRepository", "Failed to create Firebase friendship", friendshipResult.exception)
                        }
                        else -> {}
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FriendRepository", "Error syncing to Firebase", e)
                // Continue - local operation was successful
            }

            Result.Success(Unit)

        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error accepting friend request", e)
            Result.Error(e)
        }
    }

    suspend fun declineFriendRequest(requestId: Long, userId: Long): Result<Unit> {
        return try {
            android.util.Log.d("FriendRepository", "declineFriendRequest: requestId=$requestId, userId=$userId")
            
            val request = friendRequestDao.getFriendRequestById(requestId)
                ?: return Result.Error(Exception("Friend request not found"))

            // Security check: Only the receiver can decline the request
            if (request.receiverId != userId) {
                return Result.Error(SecurityException("Unauthorized to decline this request"))
            }

            // Get sender and receiver users
            val sender = userDao.getUserById(request.senderId)
            val receiver = userDao.getUserById(request.receiverId)

            // Update request status locally
            friendRequestDao.updateFriendRequestStatus(
                requestId, 
                FriendRequestStatus.DECLINED, 
                System.currentTimeMillis()
            )
            android.util.Log.d("FriendRepository", "Updated friend request status to DECLINED locally")

            // Sync to Firebase
            try {
                if (sender != null && receiver != null) {
                    val senderFirebaseUid = sender.firebaseUid
                    val receiverFirebaseUid = receiver.firebaseUid
                    
                    if (!senderFirebaseUid.isNullOrEmpty() && !receiverFirebaseUid.isNullOrEmpty()) {
                        // Find and update the Firebase friend request
                        val firebaseRequestsFlow = firestoreService.getPendingFriendRequests(receiverFirebaseUid)
                        val firebaseRequests = firebaseRequestsFlow.first()
                        val firebaseRequest = firebaseRequests.find { 
                            it.senderId == senderFirebaseUid && it.receiverId == receiverFirebaseUid 
                        }
                        
                        if (firebaseRequest != null) {
                            firestoreService.updateFriendRequestStatus(firebaseRequest.id, "DECLINED")
                            android.util.Log.d("FriendRepository", "Updated Firebase friend request to DECLINED")
                        }
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FriendRepository", "Error syncing decline to Firebase", e)
                // Continue - local operation was successful
            }

            Result.Success(Unit)

        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error declining friend request", e)
            Result.Error(e)
        }
    }

    suspend fun cancelFriendRequest(requestId: Long): Result<Unit> {
        return try {
            friendRequestDao.updateFriendRequestStatus(
                requestId, 
                FriendRequestStatus.CANCELLED, 
                System.currentTimeMillis()
            )
            Result.Success(Unit)

        } catch (e: Exception) {
            Result.Error(e)
        }
    }

    // ==================== FIREBASE SYNC ====================

    suspend fun syncFriendshipsFromFirebase(userId: Long): Result<Int> {
        return try {
            android.util.Log.d("FriendRepository", "Syncing friendships from Firebase for user: $userId")
            
            // Get user's Firebase UID
            val user = userDao.getUserById(userId) ?: return Result.Error(Exception("User not found"))
            val userFirebaseUid = user.firebaseUid
            
            if (userFirebaseUid.isNullOrEmpty()) {
                android.util.Log.w("FriendRepository", "User has no Firebase UID, skipping sync")
                return Result.Success(0)
            }

            // Get friendships from Firebase
            val firebaseFriendshipsFlow = firestoreService.getUserFriendships(userFirebaseUid)
            val firebaseFriendships = firebaseFriendshipsFlow.first()
            
            android.util.Log.d("FriendRepository", "Retrieved ${firebaseFriendships.size} friendships from Firebase")
            
            var syncedCount = 0
            
            for (firebaseFriendship in firebaseFriendships) {
                try {
                    // Find both users by Firebase UID
                    val allUsers = userDao.getAllUsers()
                    val user1 = allUsers.find { it.firebaseUid == firebaseFriendship.userId1 }
                    val user2 = allUsers.find { it.firebaseUid == firebaseFriendship.userId2 }
                    
                    if (user1 == null || user2 == null) {
                        android.util.Log.w("FriendRepository", "User not found locally for Firebase friendship: ${firebaseFriendship.id}")
                        continue
                    }
                    
                    // Check if friendship already exists locally
                    val existingFriendship = friendshipDao.getFriendshipBetweenUsers(user1.id, user2.id)
                    
                    if (existingFriendship == null) {
                        // Insert new friendship
                        val localFriendship = Friendship(
                            userId1 = user1.id,
                            userId2 = user2.id,
                            createdAt = firebaseFriendship.createdAt?.toDate()?.time ?: System.currentTimeMillis(),
                            lastInteraction = firebaseFriendship.lastInteraction?.toDate()?.time ?: System.currentTimeMillis()
                        )
                        friendshipDao.insertFriendship(localFriendship)
                        syncedCount++
                        android.util.Log.d("FriendRepository", "Synced new friendship: ${user1.username} ↔ ${user2.username}")
                    }
                } catch (e: Exception) {
                    android.util.Log.e("FriendRepository", "Error syncing individual friendship: ${firebaseFriendship.id}", e)
                }
            }
            
            android.util.Log.d("FriendRepository", "Friendship sync completed. Synced $syncedCount friendships")
            Result.Success(syncedCount)
            
        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error syncing friendships from Firebase", e)
            Result.Error(e)
        }
    }

    suspend fun syncFriendRequestsFromFirebase(userId: Long): Result<Int> {
        return try {
            android.util.Log.d("FriendRepository", "Syncing friend requests from Firebase for user: $userId")
            
            // Get user's Firebase UID
            val user = userDao.getUserById(userId) ?: return Result.Error(Exception("User not found"))
            val userFirebaseUid = user.firebaseUid
            
            if (userFirebaseUid.isNullOrEmpty()) {
                android.util.Log.w("FriendRepository", "User has no Firebase UID, skipping sync")
                return Result.Success(0)
            }

            // Get pending friend requests from Firebase
            val firebaseRequestsFlow = firestoreService.getPendingFriendRequests(userFirebaseUid)
            val firebaseRequests = firebaseRequestsFlow.first()
            
            android.util.Log.d("FriendRepository", "Retrieved ${firebaseRequests.size} friend requests from Firebase")
            
            var syncedCount = 0
            
            for (firebaseRequest in firebaseRequests) {
                try {
                    // Find sender and receiver by Firebase UID
                    val allUsers = userDao.getAllUsers()
                    val sender = allUsers.find { it.firebaseUid == firebaseRequest.senderId }
                    val receiver = allUsers.find { it.firebaseUid == firebaseRequest.receiverId }
                    
                    if (sender == null || receiver == null) {
                        android.util.Log.w("FriendRepository", "Sender or receiver not found locally for Firebase request: ${firebaseRequest.id}")
                        continue
                    }
                    
                    // Check if request already exists locally
                    val existingRequest = friendRequestDao.getPendingRequestBetweenUsers(sender.id, receiver.id)
                    
                    if (existingRequest == null) {
                        // Insert new request
                        val localRequest = FriendRequest(
                            senderId = sender.id,
                            receiverId = receiver.id,
                            status = FriendRequestStatus.valueOf(firebaseRequest.status),
                            message = firebaseRequest.message,
                            createdAt = firebaseRequest.createdAt?.toDate()?.time ?: System.currentTimeMillis(),
                            updatedAt = firebaseRequest.updatedAt?.toDate()?.time ?: System.currentTimeMillis()
                        )
                        friendRequestDao.insertFriendRequest(localRequest)
                        syncedCount++
                        android.util.Log.d("FriendRepository", "Synced new friend request: ${sender.username} → ${receiver.username}")
                    }
                } catch (e: Exception) {
                    android.util.Log.e("FriendRepository", "Error syncing individual friend request: ${firebaseRequest.id}", e)
                }
            }
            
            android.util.Log.d("FriendRepository", "Friend request sync completed. Synced $syncedCount requests")
            Result.Success(syncedCount)
            
        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error syncing friend requests from Firebase", e)
            Result.Error(e)
        }
    }

    // ==================== FRIEND MANAGEMENT ====================

    fun getFriends(userId: Long): Flow<List<User>> {
        return friendshipDao.getFriendships(userId).combine(
            userDao.getAllUsersFlow()
        ) { friendships, users ->
            friendships.mapNotNull { friendship ->
                val friendId = if (friendship.userId1 == userId) friendship.userId2 else friendship.userId1
                users.find { it.id == friendId }
            }
        }
    }

    suspend fun removeFriend(userId: Long, friendId: Long): Result<Unit> {
        return try {
            android.util.Log.d("FriendRepository", "removeFriend: userId=$userId, friendId=$friendId")
            
            // Get both users
            val user = userDao.getUserById(userId)
            val friend = userDao.getUserById(friendId)
            
            // Remove friendship locally
            friendshipDao.removeFriendship(userId, friendId)
            android.util.Log.d("FriendRepository", "Removed friendship locally")

            // Sync to Firebase
            try {
                if (user != null && friend != null) {
                    val userFirebaseUid = user.firebaseUid
                    val friendFirebaseUid = friend.firebaseUid
                    
                    if (!userFirebaseUid.isNullOrEmpty() && !friendFirebaseUid.isNullOrEmpty()) {
                        // Remove friendship from Firebase
                        firestoreService.removeFriendship(userFirebaseUid, friendFirebaseUid)
                        android.util.Log.d("FriendRepository", "Removed friendship from Firebase")
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FriendRepository", "Error removing friendship from Firebase", e)
                // Continue - local operation was successful
            }

            Result.Success(Unit)

        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error removing friend", e)
            Result.Error(e)
        }
    }

    suspend fun blockUser(blockerId: Long, blockedId: Long, reason: String? = null): Result<Unit> {
        return try {
            // Remove friendship if exists
            friendshipDao.removeFriendship(blockerId, blockedId)

            // Cancel any pending friend requests
            val pendingRequest = friendRequestDao.getPendingRequestBetweenUsers(blockerId, blockedId)
            if (pendingRequest != null) {
                friendRequestDao.updateFriendRequestStatus(
                    pendingRequest.id,
                    FriendRequestStatus.CANCELLED,
                    System.currentTimeMillis()
                )
            }

            // Add to blocked users
            val blockedUser = BlockedUser(
                blockerId = blockerId,
                blockedId = blockedId,
                reason = reason
            )
            blockedUserDao.insertBlockedUser(blockedUser)

            Result.Success(Unit)

        } catch (e: Exception) {
            Result.Error(e)
        }
    }

    suspend fun unblockUser(blockerId: Long, blockedId: Long): Result<Unit> {
        return try {
            blockedUserDao.unblockUser(blockerId, blockedId)
            Result.Success(Unit)

        } catch (e: Exception) {
            Result.Error(e)
        }
    }

    fun getBlockedUsers(userId: Long): Flow<List<User>> {
        return blockedUserDao.getBlockedUsers(userId).combine(
            userDao.getAllUsersFlow()
        ) { blockedUsers, users ->
            blockedUsers.mapNotNull { blockedUser ->
                users.find { it.id == blockedUser.blockedId }
            }
        }
    }

    suspend fun isBlocked(userId1: Long, userId2: Long): Boolean {
        return blockedUserDao.isBlocked(userId1, userId2)
    }

    suspend fun areFriends(userId1: Long, userId2: Long): Boolean {
        return friendshipDao.getFriendshipBetweenUsers(userId1, userId2) != null
    }

    suspend fun getFriendCount(userId: Long): Int {
        return friendshipDao.getFriendCount(userId)
    }

    // ==================== FRIEND SEARCH ====================

    suspend fun searchUsers(query: String, currentUserId: Long): Result<List<User>> {
        return try {
            // Use searchUsersByUsername for precise username matching (like chat search)
            val users = userDao.searchUsersByUsername(query, currentUserId)
            
            // Filter out blocked users
            val filteredUsers = users.filter { user ->
                !blockedUserDao.isBlocked(currentUserId, user.id)
            }

            Result.Success(filteredUsers)

        } catch (e: Exception) {
            Result.Error(e)
        }
    }

    suspend fun getUsersWithFriendStatus(query: String, currentUserId: Long): Result<List<UserWithFriendStatus>> {
        return try {
            android.util.Log.d("FriendRepository", "getUsersWithFriendStatus called with query: '$query', currentUserId: $currentUserId")
            
            // Get current user for logging
            val currentUser = userDao.getUserById(currentUserId)
            android.util.Log.d("FriendRepository", "Current user: ${currentUser?.username} (ID: ${currentUser?.id})")
            
            // Use searchUsersByUsername for precise username matching (like chat search)
            val users = userDao.searchUsersByUsername(query, currentUserId)
            android.util.Log.d("FriendRepository", "searchUsersByUsername returned ${users.size} users")
            users.forEach { user ->
                android.util.Log.d("FriendRepository", "Found user: ${user.username} (ID: ${user.id})")
            }
            
            val usersWithStatus = users.filter { user ->
                val isBlocked = blockedUserDao.isBlocked(currentUserId, user.id)
                android.util.Log.d("FriendRepository", "User ${user.username} blocked: $isBlocked")
                !isBlocked
            }.map { user ->
                val isFriend = areFriends(currentUserId, user.id)
                val hasPendingRequest = friendRequestDao.getPendingRequestBetweenUsers(currentUserId, user.id) != null
                val hasReceivedRequest = friendRequestDao.getPendingRequestBetweenUsers(user.id, currentUserId) != null
                
                android.util.Log.d("FriendRepository", "User ${user.username}: isFriend=$isFriend, hasPendingRequest=$hasPendingRequest, hasReceivedRequest=$hasReceivedRequest")
                
                UserWithFriendStatus(
                    user = user,
                    isFriend = isFriend,
                    hasPendingRequest = hasPendingRequest,
                    hasReceivedRequest = hasReceivedRequest
                )
            }

            android.util.Log.d("FriendRepository", "Returning ${usersWithStatus.size} users with status")
            Result.Success(usersWithStatus)

        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error in getUsersWithFriendStatus", e)
            Result.Error(e)
        }
    }

    // ==================== TEST HELPER METHODS ====================

    suspend fun getAllUsersForTesting(): Result<List<User>> {
        return try {
            val users = userDao.getAllUsers()
            android.util.Log.d("FriendRepository", "All users in database: ${users.size}")
            users.forEach { user ->
                android.util.Log.d("FriendRepository", "User: ${user.username} (ID: ${user.id})")
            }
            Result.Success(users)
        } catch (e: Exception) {
            android.util.Log.e("FriendRepository", "Error getting all users", e)
            Result.Error(e)
        }
    }

    // ==================== HELPER DATA CLASS ====================

    data class UserWithFriendStatus(
        val user: User,
        val isFriend: Boolean,
        val hasPendingRequest: Boolean,
        val hasReceivedRequest: Boolean
    )
}
